--@name Luna Mainframe | Chat
--@author The17thDoctor
--@class none

--[[
	Implements standard chat functions for modules to use.
	Can be overwritten without having to touch this library.

	It is recommend to keep those libraries getting loaded from shared in order to get updates.
]]--

if CLIENT then return end

local mfchat = {} --This is the main chat library table.

--[[
	Chat Formatting codes
	These chat formatting codes are applied for all 3 mainframe-integrated chat functions
	and more generally by any function using mfchat.parseMessage()

	All formatting codes must be enclosed by {<code>}
	If you want to escape a formatting code, you can use \\ before your brackets.
	EXAMPLE : {red}My Awesome Text in \\{white} !
	The first {red} will be caught but not \\{white}. So the text will remain red.

	Chat formatting codes cannot be into other formatting codes.
	EXAMPLE : {d {s}} IS NOT VALID AND WILL NOT WORK.

	Currently existing formatting codes:

	d <x> <y> : Any number, <x> is the number of decimals, <y> is the number format used.
	If x or y is not given, lua rules apply for each.
	EXAMPLES :
		{d}			: 3.52682 -> 3.52682
		{d 3}		: 3.52682 -> 3.53
		{d 06}		: 3.52682 -> 3.526820 (Adds trailing zeros)
		{d s}		: 1000000 -> 1 000 000
		{d s}		: 1525.15 -> 1 525.15
		{d p}		: 0.156   -> 15.6%
		{d 2 p}		: 0.15832 -> 15.83%
		{d t}		: 3031    -> 50m31s
		{d T}		: 3031	  -> 50 minutes 31 seconds
		{d -1 t}	: 3031	  -> 50m30s (Rounds up)


	s <color> : Any string, equivalent to lua concatenation.
	If a color name or a custom color is supplied, all of that text will be put in that color.
	EXAMPLES :
		{s						: My Awesome Text -> ..My Awesome Text..
		{s red					: My Awesome Text -> ..{red}My Awesome Text{previous color}..
		{s color <r> <g> <b>	: My Awesome Text -> ..{color <r> <g> <b>}My Awesome Text{previous color}..
		{s color}				: My Awesome Text -> ..{color given in arguments}My Awesome{previous color}..


	a <x> : Any angle, <x> is the number of decimals for each component.
	If <x> is not given, lua rules apply.
	EXAMPLES :
		{a}		: Angle(3.5892, 5.325, 1.2) -> Angle(3.5892, 5.325, 1.2)
		{a 3}	: Angle(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.2)
		{a 03}	: Angle(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.200) (Similar to {d 0x})


	v <x> : Any vector, <x> is the number of decimals for each component.
	If <x> is not given, lua rules apply.
	EXAMPLES :
		{v}   	: Vector(3.5892, 5.325, 1.2) -> Vector(3.5892, 5.325, 1.2)
		{v 3} 	: Vector(3.5982, 5.325, 1.2) -> Vector(3.598, 5.325, 1.2)
		{v 03} 	: Vector(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.200) (Similar to {d 0x})


	<color> : Sets the color for the following text, available colors are
	the ones inside the mfchat.color table. You can also set your own color.
	The custom color can be given either in the string to format or as a value.
	EXAMPLES :
		{red}
		{prefix}
		{color <R> <G> <B>}
		{color}


	e / E / en : Any entity
	EXAMPLES :
		{e}  : [403] ship_core
		{E}  : ship_core
		{en} : Ship Core
	NOTE : {en} is not available for all classes. If the class is not found, then {E} is used.


	p / P : Any player
	p is only the playername
	P is the playername plus his rank color
]]--

mfchat.color = {
	red			= Color.fromHSV(1.00, 0.75, 1.00),
	blue		= Color.fromHSV(0.65, 0.60, 1.00),
	green		= Color.fromHSV(0.30, 0.60, 1.00),
	orange		= Color.fromHSV(0.05, 0.75, 1.00),
	yellow		= Color.fromHSV(0.15, 0.75, 1.00),
	purple		= Color.fromHSV(0.75, 0.60, 1.00),
	gray		= Color.fromHSV(1.00, 0.00, 0.50),
	white		= Color.fromHSV(1.00, 0.00, 1.00),
	black		= Color.fromHSV(1.00, 0.00, 0.00),
	darkgray	= Color.fromHSV(1.00, 0.00, 0.25),
	darkred		= Color.fromHSV(1.00, 0.75, 0.60),
	prefix		= Color.fromHSV(0.62, 0.66, 0.70),
	warn		= Color.fromHSV(0.13, 0.75, 1.00),
	error		= Color.fromHSV(0.02, 0.75, 1.00),
}

local function explodeNoLoss(str, separator)
	local words = string.explode(str, separator, true)
	local separators = {}

	for sep in string.gmatch(str, separator) do
		separators[#separators+1] = sep
	end


	return words, separators
end

local olderr = error
function error(a, b)
	olderr(a, b)
end

local timeUnits = {
	long = { --The long name for each unit, both singular and plural.
		{"second " 	, "seconds"			},
		{"minute " 	, "minutes"			},
		{"hour "   	, "hours"			},
		{"day "    	, "days"			},
		{"week "   	, "weeks"			},
		{"month "  	, "months"			},
		{"year "   	, "years"			},
		{"decade " 	, "decades"			},
		{"century "	, "centuries"		},
	},
	short = { --The short name for each unit.
		"s", "m", "h", "d", "w", "M", "Y", "D", "C"
	},
	span = { --The length of each unit in seconds.
		1, 60, 3600, 86400, 604800, 2592000, 31536000, 315360000, 3153600000
	}
}

local checkType = libraries.checkType
local recursiveKey = {
	"This is my recursive key, its a table so you can't possibly replicate it :^)"
}

--Stores in the functions for formatting strings.
local stringFormatters = {}

function mfchat.addStringFormatter(code, func)
	checkType(code, "string", "code")
	checkType(func, "function", "func")

	local c = code:explode("[%{%}]", true)
	if #c > 1 then error("Formatter code should not contain { }", 1) end

	stringFormatters[code] = func
end

---Standard Chat Formatters

local function numberFormatter(options, values)
	checkType(values[1], "number")

	local x, y = options[1], options[2]
	local rounding, format
	local number = values[1]
	local formatTable = {}

	if tonumber(x) ~= nil then
		rounding = math.floor(tonumber(x))
		if tonumber(y) == nil then
			format = y
		else
			error("Invalid formatting code '"..formatter.."'")
		end
	end

	if format == nil then error("Invalid formatting code '"..formatter.."'") end

	if rounding ~= nil then
		if format == "p" then rounding = rounding + 2 end
		number = math.round(number, rounding)
	end

	if format == "s" then
		splt = tostring(number):explode(".")
		splt[1] = string.reverse(splt[1])
		local int, dec = "", splt[2]
		for i = 1, math.ceil(utf8.len(splt[1])/3) do
			i = (i-1) * 3 + 1
			local str = utf8.sub(splt[1], i, i+2)
			int = str.." "..int
		end

		int = utf8.sub(int, 1, utf8.len(int)-1)

		if dec ~= nil then
			number = int.."."..dec
		end

		formatTable[#formatTable+1] = int
	elseif format == "p" then
		formatTable[#formatTable+1] = tostring(number * 100).."%"
	elseif format:lower() == "t" then
		if number < 0 then error("Invalid time value (must be above -1)") end
		local names

		if format == "t" then
			names = timeUnits.short
		else
			names = timeUnits.long
		end

		local str = ""
		for i = #timeUnits.span, 1, -1 do
			if number == 0 then break end
			local span, name = timeUnits.span[i], names[i]
			local n = math.floor(number / span)

			if i == 1 then n = number end
			if rounding ~= nil then
				n = math.round(n, rounding)
			end

			if n > 0 then
				number = number - n * span
				if format == "T" then
					if n > 1 then name = name[2] else name = name[1] end
					str = str..n.." "..name.." "
				else
					str = str..n..name
				end
			end
		end

		if format == "T" then
			str = utf8.sub(str, 1, utf8.len(str)-1)
		end

		if rounding ~= nil and utf8.getChar(options[1], 1) == "0" then
			local newsplt = str:explode(".")
			str = newsplt[1]

			for i = 1, rounding - utf8.len(splt[2]) do
				newsplt[2] = newsplt[2].."0"
			end

			str = str.."."..newsplt[2]
		end
	end

	local str = tostring(number)
	if rounding ~= nil and utf8.getChar(options[1], 1) == "0" then
		local newsplt = str:explode(".")
		str = newsplt[1]
		newsplt[2] = newsplt[2] or ""

		for i = 1, rounding - utf8.len(newsplt[2]) do
			newsplt[2] = newsplt[2].."0"
		end

		str = str.."."..newsplt[2]
	end

	return {str}, 1
end

local function stringFormatter(options, values, currentTable)
	checkType(values[1], "string")

	local valuesUsed = 1
	local value = values[1]
	local formatTable = {}
	local color, r, g, b = options[1], tonumber(options[2]) or nil, tonumber(options[3]) or 0, tonumber(options[4]) or 0

	if color == nil then
		formatTable[1] = value
	else
		local previousColor = mfchat.color.white
		for i = #currentTable, 1, -1 do
			if getmetatable(currentTable[i]) == "Color" then
				previousColor = currentTable[i]
				break
			end
		end

		if mfchat.color[color] ~= nil then
			formatTable[1] = mfchat.color[color]
		elseif r ~= nil then
			formatTable[1] = Color(r, g, b)
		else
			checkType(values[2], "Color")
			formatTable[1] = values[2]
			valuesUsed = 2
		end

		formatTable[2] = value
		formatTable[3] = previousColor
	end

	return formatTable, valuesUsed
end

local function angleFormatter(options, values, currentTable)
	checkType(values[1], "Angle")

	local formatTable = {}
	local value = values[1]
	local previousColor = mfchat.color.white

	for i = #currentTable, 1, -1 do
		if getmetatable(currentTable[i]) == "Color" then
			previousColor = currentTable[i]
			break
		end
	end

	local p, y, r = value.p, value.y, value.r

	if tonumber(options[1]) ~= nil then
		p = mfchat.parseMessage("{d "..options[1].."}", p)[1]
		y = mfchat.parseMessage("{d "..options[1].."}", y)[1]
		r = mfchat.parseMessage("{d "..options[1].."}", r)[1]
	end

	local formattedTable = mfchat.parseMessage("{color}Angle({s green}, {s green}, {s green})", previousColor, p, y, r)

	for i = 1, #formattedTable do
		formatTable[#formatTable+1] = formattedTable[i]
	end

	return formatTable, 1
end

local function vectorFormatter(options, values, currentTable)
	checkType(values[1], "Vector")

	local formatTable = {}
	local value = values[1]
	local previousColor = mfchat.color.white

	for i = #currentTable, 1, -1 do
		if getmetatable(currentTable[i]) == "Color" then
			previousColor = currentTable[i]
			break
		end
	end

	local x, y, z = currentValue.x, currentValue.y, currentValue.z

	if tonumber(options[1]) ~= nil then
		x = mfchat.parseMessage("{d "..options[1].."}", x)[1]
		y = mfchat.parseMessage("{d "..options[1].."}", y)[1]
		z = mfchat.parseMessage("{d "..options[1].."}", z)[1]
	end

	local formattedTable = mfchat.parseMessage("{color}Vector({s green}, {s green}, {s green})", previousColor, x, y, z)

	for i = 1, #formattedTable do
		formatTable[#formatTable+1] = formattedTable[i]
	end

	return formatTable, 1
end

local function entityFormatter(options, values, currentTable)
	checkType(values[1], "Entity")
	local value = values[1]

	if not IsValid(value) then error("Invalid entity") end
	local previousColor = mfchat.color.white
	for i = #currentTable, 1, -1 do
		if getmetatable(currentTable[i]) == "Color" then
			previousColor = currentTable[i]
			break
		end
	end

	local id, entClass = currentValue:index(), currentValue:class()
	local formattedTable = mfchat.parseMessage("{color}[{s green}] {s}", previousColor, tostring(index), entClass)
	return formattedTable, 1
end

local function entityAltFormatter(options, values, currentTable)
	checkType(values[1], "Entity")
	local value = values[1]

	if not IsValid(value) then error("Invalid entity") end
	return {value:class()}, 1
end

local function entityNiceFormatter(options, values, currentTable)
	checkType(values[1], "Entity")
	local value = values[1]

	if not IsValid(value) then error("Invalid entity") end
	return {value:getPrintName() or value:class()}, 1
end

local function playerFormatter(options, values, currentTable)
	checkType(values[1], "Player")
	if not IsValid(values[1]) then error("Invalid player entity", 1) end
	return {values[1]:name()}, 1
end

local function playerAltFormatter(options, values, currentTable)
	checkType(values[1], "Player")
	local player = values[1]

	if not IsValid(player) then error("Invalid player entity", 1) end
	local previousColor = mfchat.color.white
	for i = #currentTable, 1, -1 do
		if getmetatable(currentTable[i]) == "Color" then
			previousColor = currentTable[i]
			break
		end
	end

	return {
		player:getTeamColor(),
		player:name(),
		previousColor
	}, 1
end

mfchat.addStringFormatter("d", numberFormatter)
mfchat.addStringFormatter("s", stringFormatter)
mfchat.addStringFormatter("a", angleFormatter)
mfchat.addStringFormatter("v", vectorFormatter)
mfchat.addStringFormatter("e", entityFormatter)
mfchat.addStringFormatter("E", entityAltFormatter)
mfchat.addStringFormatter("en", entityNiceFormatter)
mfchat.addStringFormatter("p", playerFormatter)
mfchat.addStringFormatter("P", playerAltFormatter)

function mfchat.parseMessage(message, ...)
	local words, formatters = explodeNoLoss(message, "\\?%b{}")
	local messageTable = {}
	local recursive = false
	local values = {...}
	local level = 0
	local count = 1

	--This checks if the call is coming from a recursive call.
	--If it is then all of the message table will be turned into a string.
	if values[1] == recursiveKey then
		table.remove(values, 1)
		recursive = true
		level = values[1] + 1
		table.remove(values, 1)
	end

	messageTable[1] = words[1]


	for i = 1, #formatters do
		local formatter = utf8.sub(formatters[i], 2, utf8.len(formatters[i])-1)

		local _, recursiveFormatters = explodeNoLoss(formatter, "\\?%b{}")
		if #recursiveFormatters > 0 then
			local newFormatter = mfchat.parseMessage(formatter, recursiveKey, level, ...)
			formatter = newFormatter
		end

		local components = formatter:explode(" ")

		if utf8.getChar(formatters[i], 1) == "\\" then
			messageTable[#messageTable+1] = utf8.sub(formatters[i], 2)
		else
			if stringFormatters[components[1]] ~= nil then
				local code = components[1]
				table.remove(components, 1)
				local formattedTable, toRemove = stringFormatters[code](components, values, messageTable)

				for i = 1, toRemove do
					table.remove(values, 1)
				end

				for i = 1, #formattedTable do
					messageTable[#messageTable+1] = formattedTable[i]
				end
			elseif mfchat.color[components[1]] ~= nil or components[1] == "color" then
				if mfchat.color[components[1]] ~= nil then
					messageTable[#messageTable+1] = mfchat.color[components[1]]
				else
					local r, g, b = tonumber(components[2]), tonumber(components[3]) or 0, tonumber(components[4]) or 0

					if r == nil then
						checkType(currentValue, "Color", "value #"..count, level)
						messageTable[#messageTable+1] = currentValue
						count = count + 1
					else
						messageTable[#messageTable+1] = Color(r, g, b)
					end
				end
			else
				error("Unknown string formatter: "..components[1]..".", level + 1)
			end
		end

		messageTable[#messageTable+1] = words[i+1]
	end

	if recursive then
		local success, newMessageTable = pcall(table.concat, messageTable)
		if success then
			return newMessageTable, count-1
		else
			error("Invalid recursive formatting codes.", level + 1)
		end
	end

	return messageTable
end

local tellingQueue = {}
local function startQueueEmptying()
	timer.create("Queue Emptying", 0.25, 0, function()
		local nextTell = tellingQueue[1]

		if IsValid(nextTell[2]) and chat.canTell(nextTell[2]) then
			nextTell[1](nextTell[2], unpack(nextTell[3]))
			table.remove(tellingQueue, 1)
		elseif not IsValid(nextTell[2]) then
			table.remove(tellingQueue, 1)
		end

		if #tellingQueue == 0 then
			timer.remove("Queue Emptying")
		end
	end)
end

function mfchat.say(player, message, ...)

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{prefix}{s} ➾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.say, player, messageTable}
			startQueueEmptying()
		end
	end
end

function mfchat.warn(player, message, ...)

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{warn}{s} ➾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.warn, player, messageTable}
			startQueueEmptying()
		end
	end
end

function mfchat.error(player, message, ...)

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{error}{s} ➾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.error, player, messageTable}
			startQueueEmptying()
		end
	end
end

---Commands

local commands = {}

function mfchat.addCommand(pattern, func, varNameValues)
	checkType(pattern, "string", "pattern")
	checkType(func, "function", "func")

	if varNameValues ~= nil then
		checkType(varNameValues, "table", "name and values")

		for i = 1, #varNameValues do
			checkType(varNameValues[i], "table", "name and value N°"..i)
		end
	end

	commands[#commands+1] = {
		pattern = pattern,
		func = func,
		varNameValues = varNameValues
	}
end

local function makeErrorMessage(player, pattern, results, i, expectedType)
	for j = 1, #results do
		local str = "{s}"

		if j == i then
			str = "{s orange}"
		end

		pattern = string.gsub(pattern, "%b()", str, 1)
	end

	results[#results+1] = expectedType

	mfchat.error(player, "Error in command : '"..pattern.."': expected a {s blue}.", unpack(results))
end

function mfchat.parseCommand(player, message)
	table.sort(commands, function(a, b)
		return #a.pattern:explode(" ") > #b.pattern:explode(" ")
	end)

	for i = 1, #commands do
		local pattern, func, vnv = commands[i].pattern, commands[i].func, commands[i].varNameValues
		local result = {string.find(message, pattern)}

		if #result > 0 then
			table.remove(result, 1)
			table.remove(result, 1)

			local variables = {}
			for i = 1, #result do
				local kv = vnv[i]

				if kv ~= nil then
					local k, v = kv[1], kv[2]

					if v == "player" then
						local ply = find.playerByName(result[i])
						if IsValid(ply) then
							variables[k] = ply
						else
							makeErrorMessage(player, pattern, result, i, "playername")
							return false, "error in command"
						end
					elseif v == "number" then
						local nb = tonumber(result[i])
						if nb ~= nil then
							variables[k] = nb
						else
							makeErrorMessage(player, pattern, result, i, "number")
							return false, "error in command"
						end
					end
				else
					variables[#variables+1] = result[i]
				end
			end

			return func, variables
		end
	end

	return false, "no matching command"
end

libraries.addToEnvironment("mfchat", mfchat)