--@name Luna Mainframe | Chat
--@author The17thDoctor
--@class none

--[[
	Implements standard chat functions for modules to use.
	Can be overwritten without having to touch this library.

	It is recommend to keep those libraries getting loaded from shared in order to get updates.
]]--

if CLIENT then return end

local mfchat = {} --This is the main chat library table.

--[[
	Chat Formatting codes
	These chat formatting codes are applied for all 3 mainframe-integrated chat functions
	and more generally by any function using mfchat.parseMessage()

	All formatting codes must be enclosed by {<code>}
	If you want to escape a formatting code, you can use \\ before your brackets.
	EXAMPLE : {red}My Awesome Text in \\{white} !
	The first {red} will be caught but not \\{white}. So the text will remain red.

	Chat formatting codes cannot be into other formatting codes.
	EXAMPLE : {d {s}} IS NOT VALID AND WILL NOT WORK.

	Currently existing formatting codes:

	d <x> <y> : Any number, <x> is the number of decimals, <y> is the number format used.
	If x or y is not given, lua rules apply for each.
	EXAMPLES :
		{d}			: 3.52682 -> 3.52682
		{d 3}		: 3.52682 -> 3.527
		{d 06}		: 3.52682 -> 3.526820 (Adds trailing zeros)
		{d s}		: 1000000 -> 1 000 000
		{d s}		: 1525.15 -> 1 525.15
		{d p}		: 0.156   -> 15.6%
		{d 2 p}		: 0.15832 -> 15.83%
		{d t}		: 3031    -> 50m31s
		{d T}		: 3031	  -> 50 minutes 31 seconds
		{d -1 t}	: 3031	  -> 50m30s (Rounds up)


	s <color> : Any string, equivalent to lua concatenation.
	If a color name or a custom color is supplied, all of that text will be put in that color.
	EXAMPLES :
		{s}						: My Awesome Text -> ..My Awesome Text..
		{s red}					: My Awesome Text -> ..{red}My Awesome Text{previous color}..
		{s color <r> <g> <b>}	: My Awesome Text -> ..{color <r> <g> <b>}My Awesome Text{previous color}..
		{s color}				: My Awesome Text -> ..{color given in arguments}My Awesome{previous color}..


	a <x> : Any angle, <x> is the number of decimals for each component.
	If <x> is not given, lua rules apply.
	EXAMPLES :
		{a}		: Angle(3.5892, 5.325, 1.2) -> Angle(3.5892, 5.325, 1.2)
		{a 3}	: Angle(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.2)
		{a 03}	: Angle(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.200) (Similar to {d 0x})


	v <x> : Any vector, <x> is the number of decimals for each component.
	If <x> is not given, lua rules apply.
	EXAMPLES :
		{v}   	: Vector(3.5892, 5.325, 1.2) -> Vector(3.5892, 5.325, 1.2)
		{v 3} 	: Vector(3.5982, 5.325, 1.2) -> Vector(3.598, 5.325, 1.2)
		{v 03} 	: Vector(3.5982, 5.325, 1.2) -> Angle(3.598, 5.325, 1.200) (Similar to {d 0x})


	<color> : Sets the color for the following text, available colors are
	the ones inside the mfchat.color table. You can also set your own color.
	The custom color can be given either in the string to format or as a value.
	EXAMPLES :
		{red}
		{prefix}
		{color <R> <G> <B>}
		{color}


	e / E / en : Any entity
	EXAMPLES :
		{e}  : [403] ship_core
		{E}  : ship_core
		{en} : Ship Core
	NOTE : {en} is not available for all classes. If the class is not found, then {E} is used.


	p / P : Any player
	p is only the playername
	P is the playername plus his rank color
]]--

mfchat.color = {
	red			= Color.fromHSV(1.00, 0.75, 1.00),
	blue		= Color.fromHSV(0.60, 0.60, 0.95),
	green		= Color.fromHSV(0.30, 0.60, 1.00),
	orange		= Color.fromHSV(0.05, 0.75, 1.00),
	yellow		= Color.fromHSV(0.15, 0.75, 1.00),
	purple		= Color.fromHSV(0.75, 0.60, 1.00),
	gray		= Color.fromHSV(1.00, 0.00, 0.50),
	white		= Color.fromHSV(1.00, 0.00, 0.88),
	black		= Color.fromHSV(1.00, 0.00, 0.00),
	darkgray	= Color.fromHSV(1.00, 0.00, 0.25),
	darkred		= Color.fromHSV(1.00, 0.75, 0.60),
	prefix		= Color.fromHSV(0.62, 0.66, 0.70),
	warn		= Color.fromHSV(0.13, 0.75, 1.00),
	error		= Color.fromHSV(0.02, 0.75, 1.00),

	--Ranks
	--TODO: Get SM Orang

	superadmin 			= Color.fromHex("FFFF00"),
	upperupperadmin 	= Color.fromHex("CC00CC"),
	uppermidadmin 		= Color.fromHex("CC00CC"),
	upperadmin 			= Color.fromHex("FF0000"),
	modadmin 			= Color.fromHex("00A5FF"),
	superdonatingmember = Color.fromHex("8CFF69"),
	supermember			= Color.fromHex("99F159"),
	donatingmember		= Color.fromHex("FF7800"),
	member				= Color.fromHex("00FFFF"),
	donator				= Color.fromHex("F1AA30"),
	regular				= Color.fromHex("00BE00"),
	guest				= Color.fromHex("BABABA"),
}

--Adds a color to the colors table for every other modules to use.
function mfchat.addColor(name, value)
	checkType(name, "string", "name")
	checkType(value, "Color", "color")

	mfchat.color[name] = value
end


local function explodeNoLoss(str, separator)
	local words = string.explode(str, separator, true)
	local separators = {}

	for sep in string.gmatch(str, separator) do
		separators[#separators+1] = sep
	end


	return words, separators
end

local timeUnits = {
	long = { --The long name for each unit, both singular and plural.
		{"second " 	, "seconds"			},
		{"minute " 	, "minutes"			},
		{"hour "   	, "hours"			},
		{"day "    	, "days"			},
		{"week "   	, "weeks"			},
		{"month "  	, "months"			},
		{"year "   	, "years"			},
		{"decade " 	, "decades"			},
		{"century "	, "centuries"		},
	},
	short = { --The short name for each unit.
		"s", "m", "h", "d", "w", "M", "Y", "D", "C"
	},
	span = { --The length of each unit in seconds.
		1, 60, 3600, 86400, 604800, 2592000, 31536000, 315360000, 3153600000
	}
}

local checkType = libraries.checkType
local recursiveKey = {
	"This is my recursive key, its a table so you can't possibly replicate it :^)"
}

--Stores in the functions for formatting strings.
local formatFunctions = {}

function mfchat.addStringFormatter(code, func)
	checkType(code, "string", "code")
	checkType(func, "function", "func")

	local c = code:explode("[%{%}]", true)
	if #c > 1 then error("Formatter code should not contain { }", 1) end

	formatFunctions[code] = func
end

---Standard Chat Formatters

local function lastUsedColor(messageTable)
	for i = #messageTable, 1, -1 do
		if getmetatable(messageTable[i]) == "Color" then
			return messageTable[i]
		end
	end

	return mfchat.color.white
end

local function stringFormatter(components, arguments, messageTable)
	checkType(arguments[1], "string", "value")
	local luc = lastUsedColor(messageTable)
	local argumentsUsed = 1

	if mfchat.color[components[2]] ~= nil then
		messageTable[#messageTable+1] = mfchat.color[components[2]]
		messageTable[#messageTable+1] = luc
	elseif components[2] == "color" then
		if components[3] ~= nil then
			if tonumber(components[3]) ~= nil then
				local c = Color(tonumber(components[3]), tonumber(components[4]) or 0, tonumber(components[5]) or 0)
				messageTable[#messageTable+1] = c
				messageTable[#messageTable+1] = arguments[1]
			else
				error("Invalid RGB code")
			end
		else
			checkType(arguments[2], "Color")
			messageTable[#messageTable+1] = arguments[2]
			argumentsUsed = 2
		end

		messageTable[#messageTable+1] = luc
	elseif components[2] ~= nil then
		error("Invalid color parameter '"..components[2].."'")
	else
		messageTable[#messageTable+1] = arguments[1]
	end

	return argumentsUsed
end

mfchat.addStringFormatter("s", stringFormatter)

function mfchat.parseMessage(message, ...)
	local words, formatCodes = explodeNoLoss(message, "\\?%b{}") --Catch all {} pairs (even the escaped ones)
	local messageTable = {}
	local arguments = {...}

	--We check if the call is recursive
	local recursive = arguments[1] == recursiveKey
	local level = 2

	if recursive then
		level = arguments[2]
		arguments = arguments[3]
	end

	messageTable[1] = words[1]
	for i = 1, #formatCodes do
		if utf8.getChar(formatCodes[i], 1) == "\\" then
			messageTable[#messageTable+1] = formatCodes[i]
			goto skip
		end

		do
			local formatCode = utf8.sub(formatCodes[i], 2, utf8.len(formatCodes[i])-1) --Remove {}
			local _, recursiveFormatCodes = explodeNoLoss(formatCode, "\\?%b{}")

			if #recursiveFormatCodes > 0 then
				formatCode = mfchat.parseMessage(formatCode, recursiveKey, level + 1, arguments)
			end

			local components = formatCode:explode(" ")
			if formatFunctions[components[1]] ~= nil then
				local formatter = formatFunctions[components[1]]
				local success, argumentsUsed = pcall(formatter, components, arguments, messageTable)

				if not success then
					local errorMessage = string.gsub(argumentsUsed, "SF:.*:%d+: ", "")
					error("Error for format code {"..formatCode.."} : "..errorMessage, level)
				elseif type(argumentsUsed) ~= "number" then
					error("Error for format function {"..components[1].."} : Number of arguments used missing", level)
				end

				for i = 1, argumentsUsed do
					table.remove(arguments, 1)
				end
			elseif mfchat.color[components[1]] ~= nil then
				messageTable[#messageTable+1] = mfchat.color[components[1]]
			else
				error("Unknown string format code : "..components[1], level)
			end
		end

		::skip::
		messageTable[#messageTable+1] = words[i+1] or nil
	end

	if recursive then
		local success, result = pcall(table.concat, messageTable, "")

		if success then
			return result
		else
			error("Failed to concatenate level "..(level-2).." format code", level)
		end
	else
		return messageTable
	end
end

local tellingQueue = {}
local function startQueueEmptying()
	timer.create("Queue Emptying", 0.25, 0, function()
		local nextTell = tellingQueue[1]

		if IsValid(nextTell[2]) and chat.canTell(nextTell[2]) then
			nextTell[1](nextTell[2], unpack(nextTell[3]))
			table.remove(tellingQueue, 1)
		elseif not IsValid(nextTell[2]) then
			table.remove(tellingQueue, 1)
		end

		if #tellingQueue == 0 then
			timer.remove("Queue Emptying")
		end
	end)
end

function mfchat.say(player, message, ...)
	if not IsValid(player) or not player:isPlayer() then return end

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{prefix}{s} âž¾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.say, player, messageTable}
			startQueueEmptying()
		end
	end
end

function mfchat.warn(player, message, ...)
	if not IsValid(player) or not player:isPlayer() then return end

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{warn}{s} âž¾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.warn, player, messageTable}
			startQueueEmptying()
		end
	end
end

function mfchat.error(player, message, ...)
	if not IsValid(player) or not player:isPlayer() then return end

	local prefix = mainframe.getSetting("Chat Prefix", "value") or "Luna"

	local messageTable = mfchat.parseMessage(message, ...)
	local prefixTable = mfchat.parseMessage("{error}{s} âž¾ {white}", prefix)

	for i = 1, #messageTable do
		prefixTable[#prefixTable+1] = messageTable[i]
	end

	messageTable = prefixTable

	if player == ents.owner() then
		printColor(unpack(messageTable))
	elseif IsValid(player) then
		table.insert(messageTable, 1, player)
		if chat.canTell(player) then
			chat.tell(unpack(messageTable))
		else
			tellingQueue[#tellingQueue+1] = {mfchat.error, player, messageTable}
			startQueueEmptying()
		end
	end
end

---Commands

local commands = {}

function mfchat.addCommand(pattern, func, varNameValues)
	checkType(pattern, "string", "pattern")
	checkType(func, "function", "func")

	if varNameValues ~= nil then
		checkType(varNameValues, "table", "name and values")

		for i = 1, #varNameValues do
			checkType(varNameValues[i], "table", "name and value NÂ°"..i)
		end
	end

	commands[#commands+1] = {
		pattern = pattern,
		func = func,
		varNameValues = varNameValues
	}
end

local function makeErrorMessage(player, pattern, results, i, expectedType)
	for j = 1, #results do
		local str = "{s}"

		if j == i then
			str = "{s orange}"
		end

		pattern = string.gsub(pattern, "%b()", str, 1)
	end

	results[#results+1] = expectedType

	mfchat.error(player, "Error in command : '"..pattern.."': expected {s blue}.", unpack(results))
end

function mfchat.parseCommand(player, message)
	table.sort(commands, function(a, b)
		return a.pattern > b.pattern
	end)

	for i = 1, #commands do
		local pattern, func, vnv = commands[i].pattern, commands[i].func, commands[i].varNameValues
		local result = {string.find(message, pattern)}

		if #result > 0 then
			table.remove(result, 1)
			table.remove(result, 1)

			local variables = {}
			for i = 1, #result do
				local kv = vnv[i]

				if kv ~= nil then
					local k, v = kv[1], kv[2]

					if v == "player" then
						local ply = find.playerByName(result[i])
						if IsValid(ply) then
							variables[k] = ply
						else
							--makeErrorMessage(player, pattern, result, i, "playername")
							--return false, "error in command"
							goto skip
						end
					elseif v == "number" then
						local nb = tonumber(result[i])
						if nb ~= nil then
							variables[k] = nb
						else
							--makeErrorMessage(player, pattern, result, i, "number")
							--return false, "error in command"
							goto skip
						end
					elseif v == "any" then
						variables[k] = result[i]
					elseif v:explode(":")[1] == "choice" then
						local choices = v:explode(":")[2]:explode(",")

						local found = false
						for j = 1, #choices do
							if result[i]:lower() == choices[j] then
								variables[k] = choices[j]
								found = true
								break
							end
						end

						if not found then
							--makeErrorMessage(player, pattern, result, i, table.concat(choices, ", "))
							--return false, "error in command"
							goto skip
						end
					end
				else
					variables[#variables+1] = result[i]
				end
			end

			return func, variables
		end

		::skip::
	end

	return false, "no matching command"
end

libraries.addToEnvironment("mfchat", mfchat)