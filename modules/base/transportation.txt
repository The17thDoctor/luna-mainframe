--@name Luna Mainframe | Module | Transportation
--@author The17thDoctor
--@class none

if CLIENT then return end

local warpLocations = {
	default = {
		["Hiigara"] = Vector(7266, 7675, -3878),
		["Desert"] = Vector(10959, -10129, -7022),
		["Lava"] = Vector(-10226, -106, -3185),
		["Asteroids"] = Vector(-1588, -2734, -2376),
		["Universe"] = {
			Vector(7241, -5338, -3941),
			Vector(7767, 933, -4406),
			Vector(-4622, 3250, -10870),
			Vector(219, -7203, -9816)
		},
		["Shakuras"] = Vector(-8009, -7292, 8934),
		["Station"] = Vector(8460, -9451, 9593),
		["Pegasus"] = {
			Vector(1730, -8680, 7950),
			Vector(2206, -4910, 7950),
			Vector(727, -12966, 7950)
		},
		["Earth"] = Vector(-133, 7959, 10604),
		["Moon"] = Vector(-4526, 13924, 10739),
		["Milkyway"] = {
			Vector(-12607, 8109, 8354),
			Vector(-6951, 8014, 8348),
			Vector(9205, 8197, 8995)
		},
		["Build 1"] = Vector(10495, 12284, -15153),
		["Build 2"] = Vector(10509, 4117, -15153),
		["Build 3"] = Vector(10524, -4066, -15153),
		["Build 4"] = Vector(10538, -12271, -15153),
		["Member Room"] = Vector(-92, -53, -15196),
	},
	custom  = mainframe.filedata.warpLocations or {},
}

local transLocations = {
	default = {
		["Earth"] = Vector( 2981, 8010, 8072 ),
		["Moon"] = Vector( -4222, 13478, 9957 ),

		["Shakuras"] = Vector( -7347.34, -3937, 6880 ),
		["Space Station"] = Vector( 7830.67, -5864, 9408 ),

		["Hiigara"] = Vector( 7173, 11847, -5855 ),
		["Desert"] = Vector( 11657, -10662, -9183 ),
		["Lava"] = Vector( -11090, 375, -4655 ),
		["Hell"] = Vector( -8169, -1015, -4815 ),

		["Build 1"] = Vector( 5350, 12290, -16144 ),
		["Build 2"] = Vector( 5350, 4094, -16144 ),
		["Build 3"] = Vector( 5350, -4094, -16144 ),
		["Build 4"] = Vector( 5350, -12290, -16144 ),
	},
	custom = mainframe.filedata.transLocations or {},
}

---Warping

local jumpHistory = {}

mainframe.addSetting("Favorite Drive", mainframe.SETTING_TYPE_WORD, "none", {
	choices = {
		none 						= true,
		warpdrive 					= true,
		bsg_drive 					= true,
		ship_drive 					= true,
		spore_drive 				= true,
		sg_hyperdrive 				= true,
		st_warp_drive 				= true,
		quantum_slipstream_drive 	= true,
	}
})

mfperms.registerPermission("warp", mfperms.GRANTED)
mfperms.registerPermission("warp.back", mfperms.PARENT)
mfperms.registerPermission("warp.offset", mfperms.PARENT)
mfperms.registerPermission("warp.location", mfperms.PARENT)
mfperms.registerPermission("warp.toplayer", mfperms.PARENT)
mfperms.registerPermission("warp.rotation", mfperms.PARENT)

--TSCM Drives
Module("bsg_drive", {system = "FTL Drive", entity = "BSG Drive"}, true, false, nil, {warpDrive = true})
Module("ship_drive", {system = "Ship Drive", entity = "Ship Drive"}, true, false, nil, {warpDrive = true})
Module("spore_drive", {system = "Spore Drive", entity = "Spore Drive"}, true, false, nil, {warpDrive = true})
Module("sg_hyperdrive", {system = "Hyperdrive", entity = "Hyperdrive"}, true, false, nil, {warpDrive = true})
Module("st_warp_drive", {system = "Warp Drive", entity = "Warp Drive"}, true, false, nil, {warpDrive = true})
Module("quantum_slipstream_drive", {system = "Quantum Slipstream", entity = "Quantum Slipstream Drive"}, true, false, nil, {warpDrive = true})

--Misc Drives
Module("warpdrive", {system = "Warp Drive", entity = "SBEP Drive"}, true, false, nil, {activation = "Warp", destination = "Destination", warpDrive = true})

local currentDrive

local function getCurrentDrive()
	if IsValid(currentDrive) then
		return currentDrive
	else
		local drives = mfwire.getAllModules(function(module)
			return module:extraData().warpDrive and IsValid(module)
		end)

		local drive = drives[1]
		local favoriteDrive = mainframe.getSetting("Favorite Drive", "value")
		if favoriteDrive ~= "none" then
			drive = mfwire.getModuleByClass(favoriteDrive) or drive
		end

		if IsValid(drive) then
			currentDrive = drive
		else
			currentDrive = nil
		end

		return currentDrive
	end
end

local function engageWarp(drive, position, angle, callback, dontRegister)
	if not IsValid(drive) then
		callback(false, "no drive")
		return
	end

	local extraData = drive:extraData()
	if not extraData.warpDrive then
		callback(false, "module is not a warp drive")
		return
	end

	if stargate.locationJammed(position, ents.owner()) then
		callback(false, "location jammed")
		return
	end

	local wirelink = drive:getWirelink()
	local activation, destination = extraData.activation or "Activate", extraData.destination or "Destination"

	if wirelink["Active"] == 1 then
		callback(false, "drive active")
		return
	end

	if position.isLocal then
		position.value = drive:getEntity():toWorld(position.value)
	end

	if not angle.isLocal then
		angle.value = drive:getEntity():toLocal(angle.value)
	end

	if position.value == drive:getEntity():pos() then
		callback(false, "already there")
		return
	end

	wirelink[destination] = position.value
	wirelink["Angle Offset"] = angle.value
	wirelink[activation] = 1

	timer.simple(0.2, function()
		local fail = false
		if wirelink["Blocked"] then
			callback(false, "trajectory blocked")
			fail = true
		elseif wirelink["Active"] == 0 then
			callback(false, "fail")
			fail = true
		end

		wirelink[destination] = Vector()
		wirelink["Angle Offset"] = Angle()
		wirelink[activation] = 0
		if not fail then

			if not dontRegister then
				jumpHistory[#jumpHistory+1] = {
					position = {isLocal = false, value = drive:getEntity():pos()},
					angle = {isLocal = false, value = drive:getEntity():ang()}
				}
			end

			callback(true)
		end
	end)
end

local warpActions = {
	jump   = "Jumping",
	warp   = "Warping",
	yeet   = "Yeeting",
	go     = "Going",
	travel = "Travelling"
}

do
	local function destinationWarp(player, data)

		local matches = {}

		if data.destination == "me" then
			matches[1] = {1, "you", player:pos()}
		else
			for name, value in pairs(warpLocations.default) do
				local s, e = string.find(name:lower(), data.destination)
				if s ~= nil and e ~= nil then
					matches[#matches+1] = {s, name, value}
				end
			end

			for name, value in pairs(warpLocations.custom) do
				local s, e = string.find(name:lower(), data.destination)
				if s ~= nil and e ~= nil then
					matches[#matches+1] = {s, name, value}
				end
			end

			if #matches == 0 then
				mfchat.error(player, "Location not found.")
				return
			end

			table.sort(matches, function(a, b)
				return a[1] < b[1]
			end)
		end

		local destination = matches[1]

		local name, position = destination[2]
		if type(destination[3]) == "table" then
			for i = 1, #destination[3] do
				if not stargate.locationJammed(destination[3][i], ents.owner()) then
					position = destination[3][i]
					break
				end
			end
		elseif not stargate.locationJammed(destination[3], ents.owner()) then
			position = destination[3]
		end

		if position == nil then
			mfchat.error(player, "No free position found for {s blue}.", name)
			return
		end

		position = {isLocal = false, value = position}
		local angle = {isLocal = true, value = Angle()}

		local drive = getCurrentDrive()
		if not IsValid(drive) then
			mfchat.error(player, "Warp drive not found.")
			return
		end

		engageWarp(drive, position, angle, function(success, reason)
			if success then
				if name == "you" then
					mfchat.say(player, "{s} to {s color}.", warpActions[data.action], name, player:getTeamColor())
				else
					mfchat.say(player, "{s} to {s blue}.", warpActions[data.action], name)
				end
				return
			end

			if reason == "drive active" then
				mfchat.error(player, "The ship is already {s}.", warpActions[data.action]:lower())
			elseif reason == "trajectory blocked" then
				mfchat.error(player, "Unable to {s}, trajectory blocked.", data.action)
			elseif reason == "fail" then
				mfchat.error(player, "Unable to {s} for unknown reasons.", data.action)
			elseif reason == "already there" then
				mfchat.error(player, "Unable to {s}, we are already there.", data.action)
			end
		end)
	end

	mfchat.addCommand("(%w+) to (%w+)", destinationWarp, {{"action", "choice:jump,warp,yeet,go,travel"},{"destination", "any"}})
end

do
	local function warpBack(player, data)
		if not player:isPermitted("warp.back") then
			mfchat.error("You are not allowed to warp the ship back.")
			return
		end

		local drive = getCurrentDrive()
		if not IsValid(drive) then
			mfchat.error(player, "Warp drive not found.")
			return
		end

		if #jumpHistory == 0 then
			mfchat.error(player, "No previous location registered.")
			return
		end

		local lastLocation = jumpHistory[#jumpHistory]
		engageWarp(drive, lastLocation.position, lastLocation.angle, function(success, reason)
			if success then
				mfchat.say(player, "{s} to previous location.", warpActions[data.action])
				jumpHistory[#jumpHistory] = nil
				return
			end

			if reason == "drive active" then
				mfchat.error(player, "The ship is already {s}.", warpActions[data.action]:lower())
			elseif reason == "trajectory blocked" then
				mfchat.error(player, "Unable to {s} back, trajectory blocked.", data.action)
			elseif reason == "fail" then
				mfchat.error(player, "Unable to {s} back for unknown reasons.", data.action)
			elseif reason == "already there" then
				mfchat.error(player, "Unable to {s} back, we are already there.", data.action)
			end
		end, true)
	end

	mfchat.addCommand("(%w+) back", warpBack, {{"action", "choice:jump,warp,yeet,go,travel"}})
end

do
	local directions = {
		up 		= Vector(0, 0, 1),
		down 	= Vector(0, 0, -1),
		left 	= Vector(0, 1, 0),
		right 	= Vector(0, -1, 0),
		forward = Vector(1, 0, 0),
		back 	= Vector(-1, 0, 0)
	}

	local function warpOffset(player, data)
		if not player:isPermitted("warp.offset") then
			mfchat.error(player, "You are not allowed to offset the ship.")
			return
		end

		local drive = getCurrentDrive()
		if not IsValid(drive) then
			mfchat.error(player, "Warp drive not found.")
			return
		end

		local dir = directions[data.direction]
		local amount = data.amount
		local position = {value = dir * amount, isLocal = true}
		local angle = {value = Angle(), isLocal = true}

		engageWarp(drive, position, angle, function(success, reason)
			if success then
				mfchat.say(player, "{s} {s} by {d 2} units.", warpActions[data.action], data.direction, amount)
				return
			end

			if reason == "drive active" then
				mfchat.error(player, "The ship is already {s}.", warpActions[data.action]:lower())
			elseif reason == "trajectory blocked" then
				mfchat.error(player, "Unable to {s}, trajectory blocked.", data.action)
			elseif reason == "fail" then
				mfchat.error(player, "Unable to {s} for unknown reasons.", data.action)
			elseif reason == "already there" then
				mfchat.error(player, "Unable to {s}, we are already there.", data.action)
			end
		end)
	end

	mfchat.addCommand("(%w+) (%w+) by (%w+)", warpOffset, {
		{"action", "choice:jump,warp,yeet,go,travel"},
		{"direction", "choice:up,down,left,right,forward,back"},
		{"amount", "number"}
	})
end

do
	local directions = {
		left = Angle(0, 1, 0),
		right = Angle(0, -1, 0),
	}

	function warpTurn(player, data)
		if not player:isPermitted("warp.offset") then
			mfchat.error(player, "You are not allowed to offset the ship.")
			return
		end

		local drive = getCurrentDrive()
		if not IsValid(drive) then
			mfchat.error(player, "Warp drive not found.")
			return
		end

		local dir = directions[data.direction]
		local amount = data.amount
		local position = {value = Vector(.1), isLocal = true}
		local angle = {value = dir * amount, isLocal = true}

		engageWarp(drive, position, angle, function(success, reason)
			if success then
				mfchat.say(player, "Turning {s} by {d 2}°.", data.direction, amount)
				return
			end

			if reason == "drive active" then
				mfchat.error(player, "The ship is already warping.")
			elseif reason == "trajectory blocked" then
				mfchat.error(player, "Unable to warp, trajectory blocked.")
			elseif reason == "fail" then
				mfchat.error(player, "Unable to warp for unknown reasons.")
			elseif reason == "already there" then
				mfchat.error(player, "Unable to warp, we are already there.")
			end
		end)
	end

	mfchat.addCommand("turn (%w+) by (%w+)", warpTurn, {
		{"direction", "choice:left,right"},
		{"amount", "number"}
	})

	function warpReset(player)
		if not player:isPermitted("warp.offset") then
			mfchat.error(player, "You are not allowed to offset the ship.")
			return
		end

		local drive = getCurrentDrive()
		if not IsValid(drive) then
			mfchat.error(player, "Warp drive not found.")
			return
		end

		local position = {value = Vector(.1), isLocal = true}
		local angle = {value = Angle(), isLocal = false}

		engageWarp(drive, position, angle, function(success, reason)
			if success then
				mfchat.say(player, "Aligning the ship to world angles.")
				return
			end

			if reason == "drive active" then
				mfchat.error(player, "The ship is already warping.")
			elseif reason == "trajectory blocked" then
				mfchat.error(player, "Unable to warp, trajectory blocked.")
			elseif reason == "fail" then
				mfchat.error(player, "Unable to warp for unknown reasons.")
			elseif reason == "already there" then
				mfchat.error(player, "Unable to warp, we are already there.")
			end
		end)
	end

	mfchat.addCommand("reset (%w+)", warpReset, {{"action", "choice:rotation,orientation"}})
end

---Transporter

mfperms.registerPermission("transporter", mfperms.GRANTED)
mfperms.registerPermission("transporter.topad", mfperms.PARENT)
mfperms.registerPermission("transporter.toplayer", mfperms.PARENT)
mfperms.registerPermission("transporter.tolocation", mfperms.PARENT)

Module("transporter_pad", {system = "Transporter", entity = "Transporter Pad"}, true, false, nil, {transporter = true, type = "st"})
Module("transporter", {system = "Transporter", entity = "Asgard Transporter"}, true, false, nil, {transporter = true, type = "asgard"})
Module("asgard_transporter", {system = "Transporter", entity = "Asgard Transporter"}, true, false, nil, {transporter = true, type = "asgard"})

local padCounts = {
	["models/veegi/beampad/beampad_2p.mdl"] 	= 2,
	["models/veegi/beampad/beampad.mdl"] 		= 1,
	["models/slyfo_2/telepad_standalone.mdl"] 	= 6,
	["models/slyfo_2/telepad_inhull.mdl"] 		= 6,
}

local transportActions = {
	transport	= "Transporting",
	beam		= "Beaming",
	send		= "Sending",
	take		= "Taking",
	scoop		= "Scooping"
}

local beamMode = {
	BEAM_TO_PADS = 1,
	BEAM_FROM_PADS = 2,
	BEAM_TO_VECTOR = 4,
}

local function crapgardTransport(transporter, targets, destination, mode, callback)
	if not IsValid(transporter) then
		callback(false, "transporter not found")
		return
	elseif #targets > 1 then
		callback(false, "not enough pads")
		return
	end
end

local function asgardTransport(transporter, targets, destination, mode, callback)
	if not IsValid(transporter) then
		callback(false, "transporter not found")
		return
	elseif #targets > 1 then
		callback(false, "not enough pads")
		return
	end
end

local function starTrekTransport(transporter, targets, destination, mode, callback)
	if not IsValid(transporter) then
		callback(false, "transporter not found")
		return
	elseif #targets > padCounts[transporter:getEntity():model()] then
		callback(false, "not enough pads")
		return
	end

	local wirelink = transporter:getWirelink()
	if wirelink["Energising"] == 1 then
		callback(false, "transporter energising")
		return
	end

	for i = 1, #targets do
		if IsValid(targets[i]) then
			wirelink["Target"..i] = targets[i]
		end
	end

	if mode == beamMode.BEAM_TO_PADS then

	end

	wirelink["Beam to pads"]	= bit.band(mode, beamMode.BEAM_TO_PADS)
	wirelink["Beam from pads"]	= bit.band(mode, beamMode.BEAM_FROM_PADS)
	wirelink["Beam to vector"]	= bit.band(mode, beamMode.BEAM_TO_VECTOR)

	if mode == beamMode.BEAM_TO_PADS or mode == beamMode.BEAM_FROM_PADS then
		wirelink["Energise pad"] = 1
		callback(true)
	end

	--Reset
	timer.simple(1, function()
		wirelink["Beam to pads"]	= 0
		wirelink["Beam from pads"]	= 0
		wirelink["Beam to vector"]	= 0
		wirelink["Energise pad"]	= 0
		wirelink["Keep formation"]	= 0
		wirelink["TargetLocation"]	= Vector()
		wirelink["Target Pad"]		= ents.NULL_ENTITY

		for i = 1, 6 do
			wirelink["Target"..i] = ents.NULL_ENTITY
		end
	end)
end

local function transportTargets(player, data)
	local ply = find.playerByName(data.targets)

	if data.destination == "up" then
		local tp = mfwire.getModuleByClass("transporter_pad")
		starTrekTransport(tp, {ply}, nil, beamMode.BEAM_TO_PADS, print)
	end
end

mfchat.addCommand("(%w+) (%w+) to (%w+)", transportTargets, {
	{"action", "choice:transport,beam,send,take"},
	{"targets", "any"},
	{"destination", "any"},
})

mfchat.addCommand("(%w+) (%w+) to (%w+)'?s? (%w+)", transportTargets, {
	{"action", "choice:transport,beam,send,take"},
	{"targets", "any"},
	{"destination", "any"},
	{"targetDetails", "choice:ship,pad"}
})

mfchat.addCommand("(%w+) (%w+) (up)", transportTargets, {
	{"action", "choice:transport,beam,send,take,scoop"},
	{"targets", "any"},
	{"destination", "any"},
})